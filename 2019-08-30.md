# 1.两个有序数组，寻找组合中位数  
给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。  
请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。  
你可以假设 nums1 和 nums2 不会同时为空。  
```r
示例 1:  
nums1 = [1, 3]  
nums2 = [2]  
则中位数是 2.0  

示例 2:  
nums1 = [1, 2]  
nums2 = [3, 4]  
则中位数是 (2 + 3)/2 = 2.5  
```
1)双指针法  
用两个指针分别指向两个有序数组，比较指针下元素的大小，进行指针移动，根据总移动次数来求中位数.  
```r
median <- function(x, y) {
  i <- 1  # 对x的指针
  j <- 1  # 对y的指针
  k <- 1  # 初始化结果result中的坐标
  len1 <- length(x)
  len2 <- length(y)
  len <- length(c(x, y))
  result <- numeric(length = ceiling(len / 2) + 1)  # 设定 ceiling(len / 2) + 1是为了在为偶数时能取多一个，求平均值即为中位数
  while ((k) <= ceiling(len / 2) + 1) {             # 但是，在为奇数时，也多取了一个没有用的数
    if (i <= len1 && j <= len2) {
      result[k] <- min(x[i], y[j])
      if (x[i] < y[j]) {
        i <- i + 1
      } else {
        j <- j + 1
      }

      k <- k + 1
    }
    if (i > len1 && j <= len2) {    # 如果x数组全部遍历了，后面一直遍历y数组
      result[k] <- y[j]
      j <- j + 1
      k <- k + 1
    }
    if (i <= len1 && j > len2) {    # 如果y数组全部遍历，后面一直遍历x数组
      result[k] <- x[i]
      i <- i + 1
      k <- k + 1
    }
  }
  if (len %% 2 == 0) {       # 总个数为偶数时
    return(mean(result[c(k-2, k-1)]))
  }else {
    return(result[k-2])     # 总个数为奇数时
  }                         # 要注意的时，k在while循环结束时，多加了一个1,要减去，再加上奇数时多取了一个数，因此为k-2
}
```
